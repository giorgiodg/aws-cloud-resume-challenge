---
import Layout from "../layouts/Layout.astro";
import { Prism } from "@astrojs/prism";
import "../styles/prism-xonokai.css";

const pageTitle = "Notes";
---

<Layout pageTitle={pageTitle}>
  <main>
    <h1>Challenges</h1>
    <h3>1. HTML website</h3>
    <p>
      There's not much to say here. I chose to use <a
        target="_blank"
        href="https://astro.build/">Astro</a
      > since it's a lightweight and fast framework. After having tried more complex
      frameworks like GatsbyJS and Next.js, I felt relieved by its shallow learning
      curve and by how quickly I could launch a working product.
    </p>
    <h3>2. CloudFront and S3</h3>
    <h4>Create a S3 bucket</h4>
    <p>
      Create a new bucket in your region picking up a unique name. Ensure to
      keep "ACLs disabled" and "Block all public access" enabled, while it's
      your call to leave the Bucket versioning switched on. Disable the "Static
      website hosting" option because CloudFront will take care of content
      delivery. Lastly, I suggest you tag the bucket with the key-value pair
      <i>(project,Cloud Resume Challenge)</i>.
    </p>
    <h4>Setup CloudFront</h4>
    <p>
      CloudFront works through distributions, so create a new one picking up a
      name and choosing "Single website or app". Specify Amazon S3 as the origin
      and browse through your S3 buckets to select the one hosting your website.
      Leave the origin path empty unless your index.html is <b>not</b> in the bucket
      root folder.<br />
      After having selected "Do not enable security protections" move on and create
      the distribution. It will take some minute to deploy. While the deployment
      takes place you can edit a couple of important settings.<br />
      First, modify the root object to "index.html", which will be the default file
      served when accessing the website. Second, go in the "Behavior" tab and change
      the "Viewer protocol policy" to Redirect HTTP to HTTPS to ensure the secure
      transfer of data.
    </p>
    <h4>Fix subfolder access</h4>
    <p>
      If your website is made up of subfolders that turn into URLs like /about/,
      /blog/ etc, you may come across an access denied error. Since we're not
      using the S3 static website endpoint, they will not be identified as valid
      objects. We can solve this by implementing a simple CloudFront function
      that appends index.html where necessary.
      <Prism
        lang="js"
        code={`function handler(event) {
    var request = event.request;
    var uri = request.uri;

    if (uri.endsWith('/')) {
        request.uri += 'index.html';
    } else if (!uri.includes('.')) {
        request.uri += '/index.html';
    }

    return request;
}`}
      />
    </p>
    <h3>3. Domain and SSL integration with CloudFront</h3>
    <p>TBD</p>
    <h3>4. Setup a view counter through Lambda, DynamoDB and JavaScript</h3>
    <h4>Setup DynamoDB</h4>
    <p>
      We're now going to create a view counter. Rather than accessing the
      database from our page, we will call a Lambda to fecth the value from
      DynamoDB.<br />
      Hover to DynamoDB, create a new table, and specify "id" as the Partition key.
      Tag the object with the usual pair (project,Cloud Resume Challenge). Once it
      shows as active, head to "Explore table items" to create an item with an attribute
      named "views" having a value of 1 and type set as Number.
    </p>
    <h4>Create a Lambda function</h4>
    <p>
      Let's create a Lambda function to interact with our DynamoDB table to read
      and increment the view count.<br />
      Head to AWS Lambda and click on "Create function", specify a name and choose
      your favourite runtime. I chose Node.js 22.x because of my former JavaScript
      expertise. Tag the lambda with the usual pair (project,Cloud Resume Challenge).<br
      />
      In the advanced settings, we will also enable the "Function URL" to allow interaction
      with the Lambda through HTTP requests, and set the Auth type as "NONE" to allow
      unrestricted access. We will also need to enable CORS to allowlist our website
      URL as the only allowed origin for calling the API. If you plan to test your
      Lambda from a browser or a CURL, you may <b>temporarily</b> leave that set
      to "*".
    </p>
    <p>
      Now it's time to setup the right permissions, since the Lambda will have
      to access to DynamoDB both for reading and writing. Therefore, go to the
      "Permissions" tab within the "Configuration" section and click on the
      hyperlink associated to the "Execution role". Add this IAM role the
      "AmazonDynamoDBFullAccess" policy.
    </p>
    <h4>Create the Lambda JavaScript logic</h4>
    <p>
      We'll need to create a logic to
      <ol>
        <li>
          Retrieve the current value of the "views" attribute from the table
        </li>
        <li>Increment the retrieved value by 1</li>
        <li>Update the table with the new "views" value</li>
        <li>Return the updated value as the output of the Lambda.</li>
      </ol>
      Here's the snippet code you can deploy to fullfill this:
    </p>
    <Prism
      lang="js"
      code={`
      import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";
      import { unmarshall } from "@aws-sdk/util-dynamodb";
      import { UpdateItemCommand } from '@aws-sdk/client-dynamodb';

      const client = new DynamoDBClient({ region: "<<type your AWS region>>" });
      const TABLE_NAME = "<<type your DynamoDB table>>";

      export const handler = async (event) => {
        try {
          const getCommand = new GetItemCommand({
            TableName: TABLE_NAME,
            Key: {
              id: { S: "1" }
            }
          });

          const getResponse = await client.send(getCommand);

          if (!getResponse.Item) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Item not found" }),
            };
          }

          const updateCommand = new UpdateItemCommand({
            TableName: TABLE_NAME,
            Key: {
              id: { S: "1" }
            },
            UpdateExpression: "SET #v = if_not_exists(#v, :start) + :inc",
            ExpressionAttributeNames: {
              "#v": "view"
            },
            ExpressionAttributeValues: {
              ":inc": { N: "1" },
              ":start": { N: "0" }
            },
            ReturnValues: "ALL_NEW"
          });

          const updateResponse = await client.send(updateCommand);

          const updatedItem = unmarshall(updateResponse.Attributes);

          return {
            statusCode: 200,
            body: JSON.stringify({ view: updatedItem.view }),
          };
        } catch (err) {
          console.error("Error fetching/updating item:", err);
          return {
            statusCode: 500,
            body: JSON.stringify({ error: "Internal Server Error" }),
          };
        }
      }; `}
    />
    <p>
      You can either use a CURL or a browser to invoke the Lambda and check if
      the view counter has been increased.
    </p>
    <h4>Create the website JavaScript logic</h4>
    <p>
      This JavaScript snippet fetches the view count data from the Lambda and
      updates the content of the "#views" HTML element. This is executed once
      the page loads.
    </p>
    <Prism
      lang="js"
      code={`const views = document.querySelector("#views") as HTMLElement | null;

  async function updateCounter() {
    if (!views) {
      console.error("Element not found");
      return;
    }
    try {
      const response = await fetch(
        "<<type your lambda URL>>"
      );
      let data = await response.json();
      views.innerHTML = \`Views: $\{data.view}\`;
    } catch (error) {
      console.error("Error updating view counter", error);
    }
  }

  updateCounter();`}
    /><p>
      It's up to you whether you add it as an inline &lt;script&gt; or in a
      standalone .js file that you'll have to reference in your HTML file. Just
      make sure
    </p>
    <p>
      Now that you've successfully tested the client-server interaction, it's
      time to go back to the CORS settings of your Lambda. Therefore, replace
      "*" with the Lambda URL to avoid unexpected calls.
    </p>
    <h4>Terraform (iaC)</h4>
    <p>
      This is probably the part which took longer, as I had to learn how to port
      all my past implementations and also surfaced new challenges. On the flip
      side, it allowed me to speed up testing by drastically reducing manual
      toil.
    </p>
    <p>
      So far I moved CloudFront and S3 management to Terraform. If you're
      interested in the code you can check my <a
        href="https://github.com/giorgiodg/aws-cloud-resume-challenge/tree/main/terraform"
        >GitHub repo</a
      >
    </p>
  </main></Layout
>
